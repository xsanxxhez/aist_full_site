
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Chess Pro</title>
    <!-- Используем более современную версию Stockfish через специальный скрипт worker -->

    <script src="./stockfish.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: -1;
        }

        .glow-text {
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        }

        .neon-border {
            border: 2px solid #00ffff;
            box-shadow: 0 0 15px #00ffff, inset 0 0 15px #00ffff;
            border-radius: 8px;
        }

        .neon-border-red {
            border: 2px solid #ff0080;
            box-shadow: 0 0 15px #ff0080, inset 0 0 15px #ff0080;
        }

        .container {
            max-width: 1200px;
            width: 95%;
            margin: 20px auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            letter-spacing: 3px;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #ff0080;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .game-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-container {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
            display: flex;
            justify-content: center;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 500px; /* Явное ограничение */
            height: auto; /* Важно для сохранения пропорций */
            aspect-ratio: 1/1; /* Хорошо, но добавим подстраховку */
            border: 3px solid #00ffff;
            box-shadow: 0 0 25px #00ffff;
            position: relative;
            background-color: #1a1a3a;
            overflow: hidden; /* Предотвращает "расползание" */
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }

        .square:hover {
            background-color: rgba(0, 255, 255, 0.2) !important;
        }

        .square.selected {
            background-color: rgba(255, 255, 0, 0.3) !important;
            box-shadow: 0 0 15px yellow;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            border: 3px solid rgba(255, 0, 100, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px #ff0080;
        }

        .square.check {
            background-color: rgba(255, 0, 0, 0.3) !important;
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px red; }
            50% { box-shadow: 0 0 20px red, 0 0 30px red; }
            100% { box-shadow: 0 0 10px red; }
        }

        .light {
            background-color: #2a2a4a;
        }

        .dark {
            background-color: #1a1a3a;
        }

        .controls {
            width: 100%;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-panel {
            background: rgba(10, 10, 30, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            text-align: center;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #2575fc, #6a11cb);
            color: white;
            border: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(37, 117, 252, 0.4);
        }

        .btn.active {
            background: linear-gradient(45deg, #ff0080, #ff8c00);
            box-shadow: 0 0 20px #ff0080;
        }

        .btn-secondary {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            border: 1px solid #00ffff;
        }

        .btn-secondary:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px #00ffff;
        }

        .bot-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .bot-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .bot-option:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        .bot-option input {
            width: 18px;
            height: 18px;
            accent-color: #00ffff;
        }

        .bot-option span {
            flex: 1;
        }

        .level-slider {
            width: 100%;
            margin: 15px 0;
            -webkit-appearance: none;
            height: 8px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }

        .level-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px #00ffff;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .status {
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-align: center;
            min-height: 30px;
            padding: 10px;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
        }

        .status.check {
            color: #ff5555;
            animation: pulse-red 1s infinite;
        }

        .status.mate {
            color: #ff0000;
            animation: pulse-red 1s infinite;
        }

        .status.win {
            color: #00ff00;
            animation: pulse-green 1s infinite;
        }

        @keyframes pulse-green {
            0% { text-shadow: 0 0 5px #00ff00; }
            50% { text-shadow: 0 0 15px #00ff00; }
            100% { text-shadow: 0 0 5px #00ff00; }
        }

        .moves-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .move-entry {
            margin-bottom: 5px;
        }

        .cyber-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 10% 20%, rgba(0, 255, 255, 0.05) 0%, transparent 20%),
                        radial-gradient(circle at 90% 80%, rgba(255, 0, 128, 0.05) 0%, transparent 20%);
            pointer-events: none;
            z-index: 10;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                transparent 0%,
                rgba(0, 255, 255, 0.05) 0.5%,
                transparent 1%
            );
            pointer-events: none;
            z-index: 11;
            animation: scanline 5s linear infinite;
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .subtitle {
                font-size: 1rem;
            }
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .controls {
                max-width: 100%;
            }
            .chess-board {
                max-width: 90vw;
                max-height: 90vw;
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px #00ffff; }
            50% { box-shadow: 0 0 25px #00ffff, 0 0 40px #00ffff; }
            100% { box-shadow: 0 0 15px #00ffff; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
<div class="cyber-grid"></div>
<div class="cyber-overlay"></div>
<div class="scanline"></div>
<div class="container">
    <header>
        <h1>AIST CHESS</h1>
    </header>
    <div class="game-container">
        <div class="board-container">
            <div class="chess-board" id="chessBoard">
                <!-- Доска будет создана JavaScript -->
            </div>
        </div>
        <div class="controls">
            <div class="control-panel neon-border">
                <div class="panel-title glow-text">Режим игры</div>
                <div class="mode-buttons">
                    <button class="btn active" data-mode="single">Одиночная</button>
                    <button class="btn" data-mode="bot">Против бота</button>
                </div>
            </div>
            <div class="control-panel neon-border" id="botSettings">
                <div class="panel-title glow-text">Настройки бота</div>
                <div class="bot-options">
                    <label class="bot-option">
                        <input type="radio" name="botType" value="random" checked>
                        <span>Новичок</span>
                    </label>
                    <label class="bot-option">
                        <input type="radio" name="botType" value="smart">
                        <span>Продвинутый</span>
                    </label>
                    <label class="bot-option">
                        <input type="radio" name="botType" value="master">
                        <span>Мастер (Stockfish)</span>
                    </label>
                </div>
                <div>
                    <div style="text-align: center; margin-top: 10px;">Сложность: <span id="difficultyValue">5</span></div>
                    <input type="range" min="1" max="20" value="5" class="level-slider" id="difficultySlider">
                </div>
                <div class="bot-option" style="margin-top: 10px;">
                    <input type="checkbox" id="useStockfish" checked>
                    <span>Использовать Stockfish</span>
                </div>
            </div>
            <div class="control-panel neon-border">
                <div class="panel-title glow-text">Игровая информация</div>
                <div class="game-info">
                    <div class="status glow-text" id="gameStatus">Ход белых</div>
                    <div class="moves-history" id="movesHistory">
                        <!-- История ходов -->
                    </div>
                    <div class="action-buttons">
                        <button class="btn btn-secondary" id="newGameBtn">Новая игра</button>
                        <button class="btn btn-secondary" id="undoBtn">Отмена хода</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script>
    class StockfishEngine {
        constructor() {
            this.worker = null;
            this.ready = false;
            this.initEngine();
        }

        initEngine() {
            // 1. Загружаем содержимое локального файла stockfish.js как текст
            fetch('./stockfish.js')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(workerScript => {
                    // 2. Создаем Blob из текста скрипта
                    const blob = new Blob([workerScript], { type: 'application/javascript' });
                    // 3. Создаем URL для этого Blob
                    const blobURL = URL.createObjectURL(blob);
                    // 4. Создаем Worker из Blob URL
                    this.worker = new Worker(blobURL);
                    console.log('Stockfish Worker created from local file via Blob.');

                    // 5. Настраиваем обработчики сообщений
                    this.worker.onmessage = (e) => {
                        if (e.data === 'readyok') {
                            this.ready = true;
                            console.log('Stockfish is ready!');
                        }
                    };

                    this.worker.onerror = (e) => {
                        console.error('Stockfish Worker error:', e);
                    };

                    // 6. Инициализируем Stockfish
                    this.worker.postMessage('uci');
                    this.worker.postMessage('isready');
                })
                .catch(error => {
                    console.error('Failed to load or initialize Stockfish from local file:', error);
                    this.ready = false;
                });
        }

        async analyzePosition(fen, depth = 10) {
    console.log("StockfishEngine: analyzePosition called with FEN:", fen, "Depth:", depth); // <-- Добавлено
    if (!this.ready || !this.worker) {
        console.warn('Stockfish is not ready for analysis.'); // <-- Уточнено
        return null;
    }

    return new Promise((resolve) => {
        const handler = (e) => {
            // console.log("StockfishEngine: Raw message received:", e.data); // <-- Для глубокой отладки, можно включить
            if (typeof e.data === 'string' && e.data.startsWith('bestmove')) {
                console.log("StockfishEngine: Best move received:", e.data); // <-- Добавлено
                this.worker.removeEventListener('message', handler);
                const move = this.parseBestMove(e.data);
                console.log("StockfishEngine: Parsed move:", move); // <-- Добавлено
                resolve(move);
            }
        };
        this.worker.addEventListener('message', handler);

        console.log("StockfishEngine: Sending position to Stockfish worker"); // <-- Добавлено
        this.worker.postMessage(`position fen ${fen}`);
        this.worker.postMessage(`go depth ${depth}`);
    });
}

        parseBestMove(data) {
            const parts = data.trim().split(/\s+/);
            // console.log("Parsing bestmove message:", parts); // Для отладки
            if (parts[1] && parts[1] !== '(none)') {
                const move = parts[1];
                if (move.length >= 4) {
                    return {
                        from: move.substring(0, 2),
                        to: move.substring(2, 4)
                        // Промоция идет в parts[3] если есть (например, 'promotion q')
                    };
                }
            }
            console.warn('Could not parse bestmove from Stockfish response:', data);
            return null;
        }

        destroy() {
            if (this.worker) {
                this.worker.terminate();
                // URL.revokeObjectURL не требуется для blobURL, созданного для Worker, в большинстве случаев,
                // но можно добавить, если браузер его поддерживает и не управляет им автоматически.
                // URL.revokeObjectURL(this.worker.__blobURL__); // если сохранить blobURL в worker
            }
        }
    }

        class ChessGame {
            constructor() {
                this.boardElement = document.getElementById('chessBoard');
                this.statusElement = document.getElementById('gameStatus');
                this.movesHistoryElement = document.getElementById('movesHistory');
                this.difficultySlider = document.getElementById('difficultySlider');
                this.difficultyValue = document.getElementById('difficultyValue');
                this.botSettings = document.getElementById('botSettings');
                this.useStockfishCheckbox = document.getElementById('useStockfish');

                // Улучшенные значения фигур для более точной оценки
                this.pieceValues = {
                    pawn: 100,
                    knight: 320,
                    bishop: 330,
                    rook: 500,
                    queen: 900,
                    king: 20000 // Очень высокая ценность, чтобы избежать потери короля
                };

                this.resetGame();
                this.setupEventListeners();
            }

            resetGame() {
                this.gameState = {
                    board: Array(8).fill().map(() => Array(8).fill(null)),
                    currentPlayer: 'white',
                    gameHistory: [],
                    castlingRights: {
                        white: { kingSide: true, queenSide: true },
                        black: { kingSide: true, queenSide: true }
                    },
                    enPassantTarget: null,
                    moveCount: 0,
                    gameOver: false,
                    winner: null,
                    check: false
                };

                this.selectedPiece = null;
                this.validMoves = [];
                this.gameMode = 'single'; // По умолчанию одиночная игра
                this.botType = 'random';
                this.difficulty = 5;
                this.useStockfish = true;
                this.coordsAdded = false;

                this.stockfish = new StockfishEngine();
                this.setupInitialPieces();
                this.renderBoard();
                this.updateStatus();
            }

            setupInitialPieces() {
                // Черные фигуры
                this.gameState.board[0] = [
                    {type: 'rook', color: 'black', hasMoved: false},
                    {type: 'knight', color: 'black'},
                    {type: 'bishop', color: 'black'},
                    {type: 'queen', color: 'black'},
                    {type: 'king', color: 'black', hasMoved: false},
                    {type: 'bishop', color: 'black'},
                    {type: 'knight', color: 'black'},
                    {type: 'rook', color: 'black', hasMoved: false}
                ];

                // Черные пешки
                for (let i = 0; i < 8; i++) {
                    this.gameState.board[1][i] = {type: 'pawn', color: 'black', hasMoved: false};
                }

                // Белые пешки
                for (let i = 0; i < 8; i++) {
                    this.gameState.board[6][i] = {type: 'pawn', color: 'white', hasMoved: false};
                }

                // Белые фигуры
                this.gameState.board[7] = [
                    {type: 'rook', color: 'white', hasMoved: false},
                    {type: 'knight', color: 'white'},
                    {type: 'bishop', color: 'white'},
                    {type: 'queen', color: 'white'},
                    {type: 'king', color: 'white', hasMoved: false},
                    {type: 'bishop', color: 'white'},
                    {type: 'knight', color: 'white'},
                    {type: 'rook', color: 'white', hasMoved: false}
                ];
            }

            renderBoard() {
                this.boardElement.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;

                        const piece = this.gameState.board[row][col];
                        if (piece) {
                            square.textContent = this.getPieceSymbol(piece.type, piece.color);
                        }

                        square.addEventListener('click', () => this.handleSquareClick(row, col));
                        this.boardElement.appendChild(square);
                    }
                }
                this.highlightCheck();
            }

            getPieceSymbol(type, color) {
                const symbols = {
                    king: color === 'white' ? '♔' : '♚',
                    queen: color === 'white' ? '♕' : '♛',
                    rook: color === 'white' ? '♖' : '♜',
                    bishop: color === 'white' ? '♗' : '♝',
                    knight: color === 'white' ? '♘' : '♞',
                    pawn: color === 'white' ? '♙' : '♟'
                };
                return symbols[type];
            }

            handleSquareClick(row, col) {
                if (this.gameState.gameOver) return;

                const piece = this.gameState.board[row][col];
                const color = piece ? piece.color : null;

                if (this.selectedPiece && this.isValidMove(this.selectedPiece.row, this.selectedPiece.col, row, col)) {
                    this.makeMove(this.selectedPiece.row, this.selectedPiece.col, row, col);
                    this.clearSelection();
                    this.validMoves = [];

                    // Если режим "против бота" и ход черных, запускаем ход бота
                    if (this.gameMode === 'bot' && this.gameState.currentPlayer === 'black' && !this.gameState.gameOver) {
                        setTimeout(() => this.makeBotMove(), 500);
                    }
                    return;
                }

                this.clearSelection();
                this.validMoves = [];

                if (piece && color === this.gameState.currentPlayer) {
                    this.selectedPiece = { row, col, type: piece.type, color };
                    this.getSquare(row, col).classList.add('selected');
                    this.showValidMoves(row, col, piece);
                }
            }

            getSquare(row, col) {
                return document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
            }

            clearSelection() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('selected', 'valid-move', 'valid-capture');
                });
                this.selectedPiece = null;
            }

            showValidMoves(row, col, piece) {
                this.validMoves = this.calculateValidMoves(row, col, piece);
                this.validMoves.forEach(([r, c]) => {
                    const square = this.getSquare(r, c);
                    if (this.gameState.board[r][c]) {
                        square.classList.add('valid-capture');
                    } else {
                        square.classList.add('valid-move');
                    }
                });
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                return this.validMoves.some(([r, c]) => r === toRow && c === toCol);
            }

            calculateValidMoves(row, col, piece) {
                if (!piece) return [];
                const moves = [];
                const { type, color } = piece;
                const directions = {
                    pawn: color === 'white' ? [[-1, 0]] : [[1, 0]],
                    knight: [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]],
                    bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                    rook: [[-1, 0], [0, -1], [0, 1], [1, 0]],
                    queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]],
                    king: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
                };

                if (type === 'pawn') {
                    // Простой ход вперед
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;

                    // Одна клетка вперед
                    if (this.isValidPosition(row + direction, col) && !this.gameState.board[row + direction][col]) {
                        moves.push([row + direction, col]);

                        // Две клетки вперед с начальной позиции
                        if (row === startRow && !this.gameState.board[row + 2 * direction][col]) {
                            moves.push([row + 2 * direction, col]);
                        }
                    }

                    // Взятие по диагонали
                    const captureOffsets = [[direction, -1], [direction, 1]];
                    for (const [dr, dc] of captureOffsets) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (this.isValidPosition(newRow, newCol)) {
                            const targetPiece = this.gameState.board[newRow][newCol];
                            // Взятие обычной фигуры
                            if (targetPiece && targetPiece.color !== color) {
                                moves.push([newRow, newCol]);
                            }
                            // Взятие на проходе
                            if (!targetPiece && this.gameState.enPassantTarget &&
                                this.gameState.enPassantTarget.row === newRow &&
                                this.gameState.enPassantTarget.col === newCol) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }
                } else if (type === 'knight') {
                    for (const [dr, dc] of directions[type]) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (this.isValidPosition(newRow, newCol)) {
                            const targetPiece = this.gameState.board[newRow][newCol];
                            if (!targetPiece || targetPiece.color !== color) {
                                if (!this.wouldBeInCheck(row, col, newRow, newCol, piece)) {
                                    moves.push([newRow, newCol]);
                                }
                            }
                        }
                    }
                } else if (['bishop', 'rook', 'queen'].includes(type)) {
                    const isSliding = ['bishop', 'rook', 'queen'].includes(type);
                    const pieceDirections = directions[type];

                    for (const [dr, dc] of pieceDirections) {
                        let newRow = row + dr;
                        let newCol = col + dc;

                        while (this.isValidPosition(newRow, newCol)) {
                            const targetPiece = this.gameState.board[newRow][newCol];

                            if (!targetPiece) {
                                if (!this.wouldBeInCheck(row, col, newRow, newCol, piece)) {
                                    moves.push([newRow, newCol]);
                                }
                            } else {
                                if (targetPiece.color !== color) {
                                    if (!this.wouldBeInCheck(row, col, newRow, newCol, piece)) {
                                        moves.push([newRow, newCol]);
                                    }
                                }
                                break; // Останавливаемся, если встретили фигуру
                            }

                            if (!isSliding) break; // Для короля двигаемся только на одну клетку
                            newRow += dr;
                            newCol += dc;
                        }
                    }
                } else if (type === 'king') {
                    // Обычные ходы короля
                    for (const [dr, dc] of directions[type]) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (this.isValidPosition(newRow, newCol)) {
                            const targetPiece = this.gameState.board[newRow][newCol];
                            if ((!targetPiece || targetPiece.color !== color) &&
                                !this.wouldBeInCheck(row, col, newRow, newCol, piece)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }

                    // Рокировка
                    if (!piece.hasMoved && !this.isInCheck(color)) {
                        const backRank = color === 'white' ? 7 : 0;

                        // Короткая рокировка
                        if (this.gameState.castlingRights[color].kingSide &&
                            !this.gameState.board[backRank][5] &&
                            !this.gameState.board[backRank][6] &&
                            !this.isSquareAttacked(backRank, 5, color) &&
                            !this.isSquareAttacked(backRank, 6, color)) {
                            moves.push([backRank, 6]);
                        }

                        // Длинная рокировка
                        if (this.gameState.castlingRights[color].queenSide &&
                            !this.gameState.board[backRank][1] &&
                            !this.gameState.board[backRank][2] &&
                            !this.gameState.board[backRank][3] &&
                            !this.isSquareAttacked(backRank, 3, color) &&
                            !this.isSquareAttacked(backRank, 2, color)) {
                            moves.push([backRank, 2]);
                        }
                    }
                }

                return moves;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            wouldBeInCheck(fromRow, fromCol, toRow, toCol, piece) {
                // Создаем временную копию доски
                const tempBoard = this.deepCopyBoard(this.gameState.board);
                const tempCastling = JSON.parse(JSON.stringify(this.gameState.castlingRights));
                const tempEnPassant = this.gameState.enPassantTarget ? {...this.gameState.enPassantTarget} : null;

                // Делаем временный ход
                this.makeTemporaryMove(tempBoard, fromRow, fromCol, toRow, toCol, piece);

                // Проверяем, находится ли король под шахом после хода
                return this.isInCheck(piece.color, tempBoard, tempCastling, tempEnPassant);
            }

            makeTemporaryMove(board, fromRow, fromCol, toRow, toCol, piece) {
                board[toRow][toCol] = {...piece, hasMoved: true};
                board[fromRow][fromCol] = null;

                // Обработка взятия на проходе
                if (piece.type === 'pawn' && this.gameState.enPassantTarget &&
                    toRow === this.gameState.enPassantTarget.row &&
                    toCol === this.gameState.enPassantTarget.col) {
                    const captureRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                    board[captureRow][toCol] = null;
                }

                // Обработка рокировки
                if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {
                    const isKingside = toCol > fromCol;
                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    const rookRow = fromRow;
                    board[rookRow][rookToCol] = board[rookRow][rookFromCol];
                    board[rookRow][rookFromCol] = null;
                    if (board[rookRow][rookToCol]) board[rookRow][rookToCol].hasMoved = true;
                }
            }

            isInCheck(color, board = null, castlingRights = null, enPassantTarget = null) {
                const currentBoard = board || this.gameState.board;
                const currentCastling = castlingRights || this.gameState.castlingRights;
                const currentEnPassant = enPassantTarget || this.gameState.enPassantTarget;

                let kingRow, kingCol;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = currentBoard[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                }

                if (kingRow === undefined || kingCol === undefined) return false; // Король не найден (например, на этапе инициализации)

                const opponent = color === 'white' ? 'black' : 'white';

                // Проверка пешек
                const pawnDirection = color === 'white' ? 1 : -1;
                const pawnAttacks = [[pawnDirection, -1], [pawnDirection, 1]];
                for (const [dr, dc] of pawnAttacks) {
                    const attackRow = kingRow + dr;
                    const attackCol = kingCol + dc;
                    if (this.isValidPosition(attackRow, attackCol)) {
                        const piece = currentBoard[attackRow][attackCol];
                        // Добавляем проверку на null
                        if (piece && piece.type === 'pawn' && piece.color === opponent) {
                            return true;
                        }
                    }
                }

                // Проверка коней
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                for (const [dr, dc] of knightMoves) {
                    const attackRow = kingRow + dr;
                    const attackCol = kingCol + dc;
                    if (this.isValidPosition(attackRow, attackCol)) {
                        const piece = currentBoard[attackRow][attackCol];
                        // Добавляем проверку на null
                        if (piece && piece.type === 'knight' && piece.color === opponent) {
                            return true;
                        }
                    }
                }

                // Проверка слонов, ладей, ферзей и королей
                const directions = [
                    [[-1,0], [0,-1], [0,1], [1,0]], // Прямые
                    [[-1,-1], [-1,1], [1,-1], [1,1]] // Диагонали
                ];

                for (let dirType = 0; dirType < 2; dirType++) {
                    for (const [dr, dc] of directions[dirType]) {
                        let attackRow = kingRow + dr;
                        let attackCol = kingCol + dc;
                        let steps = 0;

                        while (this.isValidPosition(attackRow, attackCol) && steps < 7) {
                            const piece = currentBoard[attackRow][attackCol];
                            if (piece) {
                                if (piece.color === opponent) {
                                    if (dirType === 0 && (piece.type === 'rook' || piece.type === 'queen')) {
                                        return true;
                                    }
                                    if (dirType === 1 && (piece.type === 'bishop' || piece.type === 'queen')) {
                                        return true;
                                    }
                                    if (steps === 0 && piece.type === 'king') {
                                        return true;
                                    }
                                }
                                break; // Останавливаемся, если встретили фигуру
                            }
                            attackRow += dr;
                            attackCol += dc;
                            steps++;
                        }
                    }
                }

                return false;
            }

            isSquareAttacked(row, col, byColor) {
                const opponent = byColor === 'white' ? 'black' : 'white';
                const currentBoard = this.gameState.board;

                // Проверка пешек
                const pawnDirection = byColor === 'white' ? -1 : 1;
                const pawnAttacks = [[pawnDirection, -1], [pawnDirection, 1]];
                for (const [dr, dc] of pawnAttacks) {
                    const attackRow = row - dr; // Инвертируем направление для проверки
                    const attackCol = col - dc;
                    if (this.isValidPosition(attackRow, attackCol)) {
                        const piece = currentBoard[attackRow][attackCol];
                        // Добавляем проверку на null
                        if (piece && piece.type === 'pawn' && piece.color === opponent) {
                            return true;
                        }
                    }
                }

                // Проверка коней
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                for (const [dr, dc] of knightMoves) {
                    const attackRow = row + dr;
                    const attackCol = col + dc;
                    if (this.isValidPosition(attackRow, attackCol)) {
                        const piece = currentBoard[attackRow][attackCol];
                        // Добавляем проверку на null
                        if (piece && piece.type === 'knight' && piece.color === opponent) {
                            return true;
                        }
                    }
                }

                // Проверка слонов, ладей, ферзей и королей
                const directions = [
                    [[-1,0], [0,-1], [0,1], [1,0]], // Прямые
                    [[-1,-1], [-1,1], [1,-1], [1,1]] // Диагонали
                ];

                for (let dirType = 0; dirType < 2; dirType++) {
                    for (const [dr, dc] of directions[dirType]) {
                        let attackRow = row + dr;
                        let attackCol = col + dc;
                        let steps = 0;

                        while (this.isValidPosition(attackRow, attackCol) && steps < 7) {
                            const piece = currentBoard[attackRow][attackCol];
                            if (piece) {
                                if (piece.color === opponent) {
                                    if (dirType === 0 && (piece.type === 'rook' || piece.type === 'queen')) {
                                        return true;
                                    }
                                    if (dirType === 1 && (piece.type === 'bishop' || piece.type === 'queen')) {
                                        return true;
                                    }
                                    if (steps === 0 && piece.type === 'king') {
                                        return true;
                                    }
                                }
                                break;
                            }
                            attackRow += dr;
                            attackCol += dc;
                            steps++;
                        }
                    }
                }

                return false;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.gameState.board[fromRow][fromCol];
                const capturedPiece = this.gameState.board[toRow][toCol];
                const moveRecord = {
                    from: {row: fromRow, col: fromCol},
                    to: {row: toRow, col: toCol},
                    piece: {...piece},
                    capturedPiece: capturedPiece ? {...capturedPiece} : null,
                    castlingRights: JSON.parse(JSON.stringify(this.gameState.castlingRights)),
                    enPassantTarget: this.gameState.enPassantTarget ? {...this.gameState.enPassantTarget} : null,
                    currentPlayer: this.gameState.currentPlayer
                };

                // Обновляем доску
                this.gameState.board[toRow][toCol] = {...piece, hasMoved: true};
                this.gameState.board[fromRow][fromCol] = null;

                // Обработка взятия на проходе
                if (piece.type === 'pawn' && this.gameState.enPassantTarget &&
                    toRow === this.gameState.enPassantTarget.row &&
                    toCol === this.gameState.enPassantTarget.col) {
                    const captureRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                    this.gameState.board[captureRow][toCol] = null;
                }

                // Обновляем право на взятие на проходе
                this.gameState.enPassantTarget = null;
                if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {
                    const enPassantRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                    this.gameState.enPassantTarget = {row: enPassantRow, col: toCol};
                }

                // Обработка рокировки
                if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {
                    const isKingside = toCol > fromCol;
                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    const rookRow = fromRow;
                    this.gameState.board[rookRow][rookToCol] = this.gameState.board[rookRow][rookFromCol];
                    this.gameState.board[rookRow][rookFromCol] = null;
                    if (this.gameState.board[rookRow][rookToCol]) this.gameState.board[rookRow][rookToCol].hasMoved = true;
                }

                // Обновляем права на рокировку
                if (piece.type === 'king') {
                    this.gameState.castlingRights[piece.color].kingSide = false;
                    this.gameState.castlingRights[piece.color].queenSide = false;
                }
                if (piece.type === 'rook') {
                    if (fromRow === (piece.color === 'white' ? 7 : 0)) {
                        if (fromCol === 0) this.gameState.castlingRights[piece.color].queenSide = false;
                        if (fromCol === 7) this.gameState.castlingRights[piece.color].kingSide = false;
                    }
                }

                // Обновляем права на рокировку для противника, если его фигура была захвачена
                const opponent = piece.color === 'white' ? 'black' : 'white';
                if (capturedPiece && capturedPiece.type === 'rook') {
                    if (toRow === (opponent === 'white' ? 7 : 0)) {
                        if (toCol === 0) this.gameState.castlingRights[opponent].queenSide = false;
                        if (toCol === 7) this.gameState.castlingRights[opponent].kingSide = false;
                    }
                }

                this.gameState.gameHistory.push(moveRecord);
                this.gameState.currentPlayer = this.gameState.currentPlayer === 'white' ? 'black' : 'white';
                this.gameState.moveCount++;
                this.renderBoard();
                this.checkGameStatus();
                this.updateStatus();
                this.updateMovesHistory();
            }

            checkGameStatus() {
                const color = this.gameState.currentPlayer;
                const opponent = color === 'white' ? 'black' : 'white';
                let hasValidMoves = false;

                outer: for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.gameState.board[row][col];
                        // Добавляем проверку на null
                        if (piece && piece.color === color) {
                            const moves = this.calculateValidMoves(row, col, piece);
                            if (moves.length > 0) {
                                hasValidMoves = true;
                                break outer;
                            }
                        }
                    }
                }

                const inCheck = this.isInCheck(color);
                if (!hasValidMoves) {
                    this.gameState.gameOver = true;
                    this.gameState.winner = inCheck ? opponent : 'draw';
                    this.gameState.check = inCheck;
                } else {
                    this.gameState.check = inCheck;
                }
            }

            updateStatus() {
                if (this.gameState.gameOver) {
                    if (this.gameState.winner === 'draw') {
                        this.statusElement.textContent = 'ПАТ!';
                        this.statusElement.className = 'status win glow-text';
                    } else {
                        const winner = this.gameState.winner === 'white' ? 'БЕЛЫЕ' : 'ЧЕРНЫЕ';
                        this.statusElement.textContent = `${winner} ПОБЕДИЛИ!`;
                        this.statusElement.className = 'status mate glow-text';
                    }
                } else {
                    const playerNames = {white: 'БЕЛЫХ', black: 'ЧЕРНЫХ'};
                    if (this.gameState.check) {
                        this.statusElement.textContent = `ШАХ! ХОД ${playerNames[this.gameState.currentPlayer]}`;
                        this.statusElement.className = 'status check glow-text';
                    } else {
                        this.statusElement.textContent = `ХОД ${playerNames[this.gameState.currentPlayer]}`;
                        this.statusElement.className = 'status glow-text';
                    }
                }
            }

            updateMovesHistory() {
                this.movesHistoryElement.innerHTML = '';
                for (let i = 0; i < this.gameState.gameHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = this.gameState.gameHistory[i];
                    const blackMove = this.gameState.gameHistory[i + 1];

                    const moveEntry = document.createElement('div');
                    moveEntry.className = 'move-entry';
                    moveEntry.textContent = `${moveNumber}. ${this.formatMove(whiteMove)} ${blackMove ? this.formatMove(blackMove) : ''}`;
                    this.movesHistoryElement.appendChild(moveEntry);
                }
                // Прокручиваем вниз
                this.movesHistoryElement.scrollTop = this.movesHistoryElement.scrollHeight;
            }

            formatMove(move) {
                if (!move || !move.piece) return '';
                const pieceSymbol = this.getPieceSymbol(move.piece.type, move.piece.color);
                const fromCol = String.fromCharCode(97 + move.from.col);
                const fromRow = 8 - move.from.row;
                const toCol = String.fromCharCode(97 + move.to.col);
                const toRow = 8 - move.to.row;

                let moveStr = `${pieceSymbol}${fromCol}${fromRow}-${toCol}${toRow}`;
                if (move.capturedPiece) {
                    moveStr += `x${this.getPieceSymbol(move.capturedPiece.type, move.capturedPiece.color)}`;
                }
                return moveStr;
            }

            highlightCheck() {
                document.querySelectorAll('.square').forEach(square => {
                    square.classList.remove('check');
                });

                if (this.isInCheck(this.gameState.currentPlayer)) {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = this.gameState.board[row][col];
                            // Добавляем проверку на null
                            if (piece && piece.type === 'king' && piece.color === this.gameState.currentPlayer) {
                                this.getSquare(row, col).classList.add('check');
                                return;
                            }
                        }
                    }
                }
            }

            deepCopyBoard(board) {
                return board.map(row => row.map(piece => piece ? {...piece} : null));
            }

            getFEN() {
                let fen = '';
                for (let row = 0; row < 8; row++) {
                    let emptySquares = 0;
                    for (let col = 0; col < 8; col++) {
                        const piece = this.gameState.board[row][col];
                        if (piece) {
                            if (emptySquares > 0) {
                                fen += emptySquares;
                                emptySquares = 0;
                            }
                            const pieceChar = piece.type === 'knight' ? 'n' : piece.type.charAt(0);
                            fen += piece.color === 'white' ? pieceChar.toUpperCase() : pieceChar;
                        } else {
                            emptySquares++;
                        }
                    }
                    if (emptySquares > 0) {
                        fen += emptySquares;
                    }
                    if (row < 7) fen += '/';
                }

                fen += ` ${this.gameState.currentPlayer === 'white' ? 'w' : 'b'} `;
                let castling = '';
                if (this.gameState.castlingRights.white.kingSide) castling += 'K';
                if (this.gameState.castlingRights.white.queenSide) castling += 'Q';
                if (this.gameState.castlingRights.black.kingSide) castling += 'k';
                if (this.gameState.castlingRights.black.queenSide) castling += 'q';
                fen += castling || '-';
                fen += this.gameState.enPassantTarget ? ` ${String.fromCharCode(97 + this.gameState.enPassantTarget.col)}${8 - this.gameState.enPassantTarget.row}` : ' -';
                return fen + ' 0 1';
            }

            notationToCoords(notation) {
    if (!notation || typeof notation !== 'string' || notation.length !== 2) {
        console.error("Invalid notation:", notation);
        return null;
    }

    const file = notation.charCodeAt(0); // Преобразуем букву в код ASCII ('a' -> 97)
    const rank = parseInt(notation[1], 10); // Преобразуем цифру в число

    // Проверяем диапазон
    if (file < 97 || file > 104 || rank < 1 || rank > 8) {
        console.error("Notation out of bounds:", notation);
        return null;
    }

    const col = file - 97; // 'a' -> 0, 'h' -> 7
    const row = 8 - rank;  // '8' -> 0, '1' -> 7

    return { row, col };
}

            async makeBotMove() {
                if (this.gameMode !== 'bot' || this.gameState.currentPlayer !== 'black' || this.gameState.gameOver) return;

                // Попытка использовать Stockfish
                if (this.useStockfish && this.botType === 'master' && this.stockfish.ready) {
                    try {
                        const fen = this.getFEN();
                        const bestMove = await this.stockfish.analyzePosition(fen, this.difficulty);
                        if (bestMove) {
                            const from = this.notationToCoords(bestMove.from);
                            const to = this.notationToCoords(bestMove.to);
                            if (this.isValidMove(from.row, from.col, to.row, to.col)) {
                                this.makeMove(from.row, from.col, to.row, to.col);
                                return;
                            }
                        }
                    } catch (e) {
                        console.error('Stockfish error:', e);
                    }
                }

                // Альтернативные боты
                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.gameState.board[row][col];
                        // Добавляем проверку на null
                        if (piece && piece.color === 'black') {
                            const moves = this.calculateValidMoves(row, col, piece);
                            moves.forEach(([toRow, toCol]) => {
                                allMoves.push({from: {row, col}, to: {row: toRow, col: toCol}, piece});
                            });
                        }
                    }
                }

                if (allMoves.length > 0) {
                    let selectedMove;
                    if (this.botType === 'random') {
                        selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                    } else { // 'smart'
                        selectedMove = this.getSmartMove(allMoves);
                    }

                    // Добавляем проверку на null для selectedMove
                    if (selectedMove) {
                        setTimeout(() => {
                            this.makeMove(
                                selectedMove.from.row,
                                selectedMove.from.col,
                                selectedMove.to.row,
                                selectedMove.to.col
                            );
                        }, 300);
                    }
                }
            }

            // Улучшенный "умный" бот
            getSmartMove(moves) {
                if (!moves || moves.length === 0) return null;

                let bestMove = null;
                let bestScore = -Infinity;

                for (const move of moves) {
                    // Добавляем проверку на null для move.piece
                    if (!move.piece) continue;

                    let score = 0;

                    // 1. Оценка материала (взятие фигур)
                    const targetPiece = this.gameState.board[move.to.row][move.to.col];
                    if (targetPiece) {
                        score += this.pieceValues[targetPiece.type] || 0;
                    }

                    // 2. Центральный контроль (пешки и кони в центре ценятся больше)
                    if (move.piece.type === 'pawn' || move.piece.type === 'knight') {
                        const isCentral = (move.to.row >= 2 && move.to.row <= 5) && (move.to.col >= 2 && move.to.col <= 5);
                        if (isCentral) score += 10;
                    }

                    // 3. Развитие фигур в начале игры
                    if (this.gameState.moveCount < 20) {
                        if (move.piece.type === 'knight' || move.piece.type === 'bishop') {
                            // Поощряем развитие коней и слонов
                            score += 20;
                        }
                        if (move.piece.type === 'queen' && Math.abs(move.from.col - move.to.col) > 1) {
                            // Поощряем активное размещение ферзя
                            score += 15;
                        }
                    }

                    // 4. Защита собственных фигур
                    // (Это сложнее, требует анализа атакующих линий)

                    // 5. Избегание ходов под шах
                    // (уже учтено в calculateValidMoves через wouldBeInCheck)

                    // 6. Продвижение пешек
                    if (move.piece.type === 'pawn') {
                        const promotionRow = move.piece.color === 'white' ? 0 : 7;
                        if (move.to.row === promotionRow) {
                            // Огромный бонус за превращение
                            score += 1000;
                        } else {
                            // Небольшой бонус за продвижение
                            const progress = move.piece.color === 'white' ? (6 - move.to.row) : (move.to.row - 1);
                            score += progress * 5;
                        }
                    }

                    // 7. Атака короля противника (ближе к мату)
                    // (Это сложнее, требует более глубокого анализа)

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                // Если не нашли хороших ходов, выбираем случайный
                return bestMove || moves[Math.floor(Math.random() * moves.length)];
            }

            undoMove() {
                if (this.gameState.gameHistory.length === 0) return;

                const lastMove = this.gameState.gameHistory.pop();

                // Восстанавливаем состояние доски
                this.gameState.board = this.deepCopyBoard(this.gameState.board);

                // Возвращаем фигуру на исходную позицию
                this.gameState.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;

                // Возвращаем захваченную фигуру или очищаем клетку
                if (lastMove.capturedPiece) {
                    this.gameState.board[lastMove.to.row][lastMove.to.col] = lastMove.capturedPiece;
                } else {
                    this.gameState.board[lastMove.to.row][lastMove.to.col] = null;
                }

                // Обработка специальных ходов (рокировка, взятие на проходе)
                // Это упрощенная версия, в реальной игре нужно более точное восстановление
                if (lastMove.piece.type === 'king' && Math.abs(lastMove.from.col - lastMove.to.col) === 2) {
                    // Восстанавливаем ладью при рокировке
                    const isKingside = lastMove.to.col > lastMove.from.col;
                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    const rookRow = lastMove.from.row;

                    // Перемещаем ладью обратно
                    this.gameState.board[rookRow][rookFromCol] = this.gameState.board[rookRow][rookToCol];
                    this.gameState.board[rookRow][rookToCol] = null;
                }

                // Восстанавливаем другие параметры игры
                this.gameState.castlingRights = lastMove.castlingRights;
                this.gameState.enPassantTarget = lastMove.enPassantTarget;
                this.gameState.currentPlayer = lastMove.currentPlayer;
                this.gameState.moveCount--;

                // Сбрасываем флаги окончания игры
                this.gameState.gameOver = false;
                this.gameState.winner = null;
                this.gameState.check = false;

                this.renderBoard();
                this.checkGameStatus(); // Перепроверяем статус после отмены
                this.updateStatus();
                this.updateMovesHistory();
            }

            setupEventListeners() {
                // Кнопки режима игры
                document.querySelectorAll('.mode-buttons .btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-buttons .btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.gameMode = btn.dataset.mode;
                        this.botSettings.style.display = this.gameMode === 'bot' ? 'block' : 'none';
                    });
                });

                // Радиокнопки типа бота
                document.querySelectorAll('input[name="botType"]').forEach(radio => {
                    radio.addEventListener('change', () => this.botType = radio.value);
                });

                // Слайдер сложности
                this.difficultySlider.addEventListener('input', () => {
                    this.difficulty = parseInt(this.difficultySlider.value);
                    this.difficultyValue.textContent = this.difficulty;
                });

                // Кнопка "Новая игра"
                document.getElementById('newGameBtn').addEventListener('click', () => this.resetGame());

                // Кнопка "Отмена хода"
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());

                // Чекбокс использования Stockfish
                this.useStockfishCheckbox.addEventListener('change', () => {
                    this.useStockfish = this.useStockfishCheckbox.checked;
                });

                // Скрываем настройки бота по умолчанию
                this.botSettings.style.display = 'none';
            }
        }

        // Инициализация игры после загрузки DOM
        document.addEventListener('DOMContentLoaded', () => {
            new ChessGame();
        });
</script>
</body>
</html>
